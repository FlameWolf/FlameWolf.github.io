<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>Enc-Dec</title>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tiny.css@0.12/dist/tiny.css"/>
		<style type="text/css">
			:root {
				--padding: 0.75rem;
				--border-radius: 0.5rem;
				--shadow-color: light-dark(rgba(0, 0, 0, 0.25), rgba(0, 0, 0, 0.75));
				--box-shadow: 0 0 0.5rem var(--shadow-color);
				--box-shadow-hover: 0 0 0.75rem var(--shadow-color);
				--margin: 0.75rem;
				--primary-color: #2563eb;
				--primary-hover: #1d4ed8;
				--success-color: #16a34a;
				--error-color: #dc2626;
				--border-color: light-dark(#d1d5db, #374151);
				--text-muted: light-dark(#6b7280, #9ca3af);
				--focus-ring: light-dark(#3b82f6, #60a5fa);
				--transition: all 0.25s ease-in-out;
				color-scheme: light dark;
			}
			* {
				box-sizing: border-box;
			}
			body {
				background-color: light-dark(white, #111827);
				color: light-dark(#111827, #f3f4f6);
				font-family: system-ui, -apple-system, sans-serif;
				line-height: 1.6;
				min-width: min-content;
				padding: 2rem 1rem;
				margin: 0 auto;
			}
			.toast {
				display: flex;
				align-items: center;
				justify-content: center;
				background-color: #1f2937;
				color: white;
				font-size: 0.95rem;
				cursor: pointer;
				padding: var(--padding) calc(var(--padding) * 2);
				border-radius: var(--border-radius);
				position: fixed;
				top: 1.5rem;
				right: 1.5rem;
				opacity: 0;
				box-shadow: var(--box-shadow-hover);
				transform: translateX(calc(100% + 2rem));
				transition: var(--transition);
				&.success,
				&.error {
					opacity: 1;
					transform: none;
				}
				&.success {
					background-color: var(--success-color);
				}
				&.error {
					background-color: var(--error-color);
				}
			}
			button {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				background-color: light-dark(white, #1f2937);
				color: light-dark(#374151, #e5e7eb);
				font-size: 0.9rem;
				padding: 0.625rem 1.5rem;
				border: 1px solid var(--border-color);
				border-radius: var(--border-radius);
				transition: var(--transition);
				&:hover:not(:disabled) {
					background-color: light-dark(#f9fafb, #374151);
					border-color: light-dark(#9ca3af, #4b5563);
					box-shadow: inset 0 0 0.25rem currentColor;
				}
				&:focus-visible {
					outline: 2px solid var(--focus-ring);
					outline-offset: 2px;
				}
				&:disabled,
				&:disabled:hover {
					background-color: light-dark(#f3f4f6, #1f2937);
					color: light-dark(#9ca3af, 4b5563);
					cursor: default;
					border-color: light-dark(#e5e7eb, #374151);
				}
				&#encrypt,
				&#decrypt {
					background-color: var(--primary-color);
					color: white;
					border-color: var(--primary-color);
				}
				&#encrypt:hover:not(:disabled),
				&#decrypt:hover:not(:disabled) {
					background-color: var(--primary-hover);
					border-color: var(--primary-hover);
				}
			}
			.tab-container {
				display: flex;
				flex-direction: column;
				gap: calc(var(--margin) * 2);
				> .tab-bar {
					display: flex;
					gap: 0.25rem;
					background-color: light-dark(#f3f4f6, #1f2937);
					width: 100%;
					padding: 0.25rem;
					border: 1px solid var(--border-color);
					border-radius: calc(var(--border-radius) + 0.25rem);
					> .tab-btn {
						flex: 1;
						align-items: center;
						justify-content: center;
						background-color: transparent;
						color: var(--text-muted);
						font-size: 0.95rem;
						padding: 0.625rem 1.75rem;
						border: none;
						border-radius: var(--border-radius);
						transition: var(--transition);
						&:hover:not(.active) {
							background-color: light-dark(#e5e7eb, #374151);
							color: light-dark(#374151, #e5e7eb);
						}
						&.active {
							background-color: var(--primary-color);
							color: white;
						}
						&:focus-visible {
							outline: 2px solid var(--focus-ring);
							outline-offset: -2px;
						}
					}
				}
			}
			.hidden {
				display: none;
			}
			.grid {
				display: grid;
				grid-auto-flow: row;
				gap: calc(var(--margin) * 1.5);
				> .row {
					display: grid;
					grid-auto-flow: column;
					align-items: center;
					gap: var(--margin);
					&.warning {
						padding: var(--padding) calc(var(--padding) * 2);
						border: solid 1px darkviolet;
						border-radius: var(--border-radius);
						> .cell > em {
							text-align: center;
							width: 100%;
						}
					}
					&.footer {
						color: var(--text-muted);
						font-size: 0.8rem;
						> .cell > em {
							overflow-wrap: anywhere;
						}
					}
					&.hidden {
						display: none;
					}
					> .cell {
						display: flex;
						gap: var(--margin);
					}
				}
			}
			.encrypt-key-holder {
				display: grid;
				grid-template-columns: 1fr auto;
				grid-template-rows: auto auto;
				gap: calc(var(--margin) * 1.5);
				width: 100%;
				> .key {
					grid-column: 1 / span 1;
					grid-row: 1 / span 1;
				}
				> .message {
					display: flex;
					align-items: center;
					grid-column: 1 / span 1;
					grid-row: 2 / span 1;
					background-color: light-dark(#fef3c7, #451a03);
					color: light-dark(#92400e, #fde68a);
					font-size: 0.95rem;
					line-height: 1.5;
					padding: calc(var(--padding) * 1.5);
					border-style: solid;
					border-width: 1px;
					border-color: light-dark(#fde68a, #78350f);
					border-radius: var(--border-radius);
				}
				> .qr-code {
					display: block;
					grid-column: 2 / span 1;
					grid-row: 1 / span 2;
					width: 256px;
					height: 256px;
					padding: 0.5rem;
					border: 2px solid var(--border-color);
					border-radius: var(--border-radius);
					background-color: white;
				}
			}
			.separator {
				border: solid 1px var(--background-hover);
			}
			textarea {
				font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
				font-size: 0.95rem;
				line-height: 1.5;
				width: 100%;
				min-height: 32rem;
				padding: calc(var(--padding) * 1.25);
				border: 1px solid var(--border-color);
				border-radius: var(--border-radius);
				background-color: light-dark(#fafafa, #1f2937);
				color: light-dark(#111827, #f3f4f6);
				resize: vertical;
				transition: var(--transition);
				&:focus {
					outline: 2px solid var(--focus-ring);
					outline-offset: -1px;
					border-color: var(--focus-ring);
					background-color: light-dark(white, #111827);
				}
				&.key {
					font-size: 0.875rem;
					font-weight: bold;
					min-height: 4.5rem;
					background-color: light-dark(#f9fafb, #1f2937);
					resize: none;
				}
				&[readonly] {
					background-color: light-dark(#f3f4f6, #1f2937);
					color: light-dark(#4b5563, #9ca3af);
				}
			}
			.overlay {
				cursor: wait;
				width: 100vw;
				height: 100vh;
				position: fixed;
				top: 0;
				left: 0;
			}
			@media (width >= 768px) {
				.align-end {
					justify-content: end;
				}
			}
			@media (width < 768px) {
				body {
					padding: 1rem 0.75rem;
				}
				.grid > .row {
					grid-auto-flow: row;
					> .cell {
						justify-content: center;
						text-align: center;
						> button {
							flex: 1;
							padding: var(--padding);
						}
					}
				}
				.encrypt-key-holder {
					display: flex;
					flex-direction: column;
					> .qr-code {
						align-self: center;
						width: unset;
						height: fit-content;
					}
				}
				textarea {
					min-height: 32rem;
				}
			}
			@media (width < 480px) {
				:root {
					--padding: 0.5rem;
					--margin: 0.5rem;
				}
				.toast {
					top: 1rem;
					right: 0.75rem;
					left: 0.75rem;
				}
			}
		</style>
		<script type="text/javascript" src="JavaScript/qrcode.min.js"></script>
		<script type="text/javascript" src="JavaScript/sample-texts.js"></script>
		<script type="text/javascript" src="JavaScript/is-text-file.js"></script>
		<script type="text/javascript" src="JavaScript/gzip.js"></script>
		<script type="text/javascript" src="JavaScript/base-95.js"></script>
		<script type="text/javascript">
			"use strict";

			document.addEventListener("DOMContentLoaded", async () => {
				const emptyString = "";
				const ivLength = 8;
				const imgDim = 256;
				const [encoder, decoder] = [new TextEncoder(), new TextDecoder()];
				const keyName = "AES-GCM";
				const keyOps = ["encrypt", "decrypt"];
				const keyFormat = "jwk";
				const encryptKey = await crypto.subtle.generateKey(
					{
						name: keyName,
						length: 256
					},
					true,
					keyOps
				);
				const jwkBase = {
					alg: "A256GCM",
					ext: true,
					key_ops: keyOps,
					kty: "oct"
				};
				const encryptKeySecret = (await crypto.subtle.exportKey(keyFormat, encryptKey)).k;
				const encryptKeyQr = QRCode({
					msg: encryptKeySecret,
					dim: imgDim,
					pal: ["#000000", "#FFFFFF"]
				});
				const getEncryptionParams = (key, iv, data) => [
					{
						name: "AES-GCM",
						iv
					},
					key,
					data
				];
				const divToast = document.getElementById("toast");
				const divTrailingSpacesMessage = document.getElementById("trailing-spaces-message");
				const divOverlay = document.getElementById("overlay");
				const imgEncryptKeyQrCode = document.getElementById("encrypt-key-qr-code");
				const ancInsertSample = document.getElementById("insert-sample");
				const btnEncrypt = document.getElementById("encrypt");
				const btnDecrypt = document.getElementById("decrypt");
				const txtEncryptKey = document.getElementById("encrypt-key");
				const txtPlainText = document.getElementById("plain-text");
				const txtEncryptedOutput = document.getElementById("encrypted-output");
				const txtDecryptKey = document.getElementById("decrypt-key");
				const txtCipherText = document.getElementById("cipher-text");
				const txtDecryptedOutput = document.getElementById("decrypted-output");
				const spnTrailingSpaceCount = document.getElementById("trailing-space-count");
				const emPlainTextByteCount = document.getElementById("plain-text-bytes");
				const emEncryptedOutputByteCount = document.getElementById("encrypted-output-bytes");
				const emCipherTextByteCount = document.getElementById("cipher-text-bytes");
				const emDecryptedOutputByteCount = document.getElementById("decrypted-output-bytes");
				const emPlainToEncryptedRatio = document.getElementById("plain-to-encrypted-ratio");
				const emEncryptedToPlainRatio = document.getElementById("encrypted-to-plain-ratio");
				const tmpQrCode = new Image();
				let toastTimeout = null;
				const hideToast = () => {
					if (toastTimeout) {
						clearTimeout(toastTimeout);
						toastTimeout = null;
					}
					divToast.className = "toast";
				};
				const showToast = (message, success) => {
					hideToast();
					divToast.textContent = message;
					divToast.classList.add(success ? "success" : "error");
					toastTimeout = setTimeout(hideToast, 1500);
				};
				const updateValue = async (element, value) => {
					element.value = emptyString;
					if (value === emptyString) {
						element.dispatchEvent(new Event("input"));
						return;
					}
					await new Promise(resolve =>
						setTimeout(() => {
							element.value = value;
							element.dispatchEvent(new Event("input"));
							resolve();
						}, 250)
					);
				};
				const insertSampleText = async (lang, inputElement) => {
					const sampleText = sampleTexts[lang];
					if (!sampleText) {
						showToast("No sample text available", false);
						return;
					}
					await updateValue(inputElement, sampleText);
					showToast("Sample text inserted", true);
				};
				const unicodeToBase95 = async input => encodeBase95(await gzip(encoder.encode(input)));
				const base95ToUnicode = async input => decoder.decode(await gunzip(decodeBase95(input)));
				const encryptMessage = async (key, iv, plainText) => await crypto.subtle.encrypt(...getEncryptionParams(key, iv, await gzip(encoder.encode(plainText))));
				const decryptMessage = async (key, iv, ciphertext) => decoder.decode(await gunzip(await crypto.subtle.decrypt(...getEncryptionParams(key, iv, ciphertext))));
				const withUiBlocked = async (callback, errorMessage) => {
					try {
						divOverlay.classList.remove("hidden");
						await callback();
					} catch (err) {
						showToast(errorMessage ?? `Error: ${err.message}`, false);
					} finally {
						divOverlay.classList.add("hidden");
					}
				};
				const pasteToTarget = async event => {
					await withUiBlocked(async () => {
						const sender = event.target;
						const targetElement = document.getElementById(sender.dataset["target"]);
						const clipboardText = await navigator.clipboard.readText();
						if (clipboardText) {
							await updateValue(targetElement, clipboardText);
							showToast("Pasted from clipboard", true);
						} else {
							showToast("Nothing to paste", false);
						}
					}, "Failed to paste");
				};
				const copyFromSource = async event => {
					await withUiBlocked(async () => {
						const sender = event.target;
						const sourceElement = document.getElementById(sender.dataset["source"]);
						const text = sourceElement.value;
						if (!text) {
							showToast("Nothing to copy", false);
							return;
						}
						await navigator.clipboard.writeText(text);
						showToast("Copied to clipboard", true);
					}, "Failed to copy");
				};
				const triggerUpload = async event => {
					document.getElementById(event.target.dataset["target"]).click();
				};
				const uploadFile = async event => {
					await withUiBlocked(async () => {
						const sender = event.target;
						const targetElement = document.getElementById(sender.dataset["target"]);
						const file = sender.files[0];
						if (file) {
							const reader = new FileReader();
							reader.onload = async progressEvent => {
								await updateValue(targetElement, progressEvent.target.result);
								showToast("File loaded", true);
							};
							if (file.type?.startsWith("text/") || (await isTextFile(file))) {
								reader.readAsText(file);
							} else {
								showToast("Only text files are supported", false);
							}
						}
						sender.value = null;
					}, "Failed to read file");
				};
				const downloadFile = async event => {
					await withUiBlocked(() => {
						const sender = event.target;
						const sourceElement = document.getElementById(sender.dataset["source"]);
						const text = sourceElement.value;
						if (text) {
							const blob = new Blob([text], { type: "text/plain" });
							const url = URL.createObjectURL(blob);
							const anchorElement = document.createElement("a");
							anchorElement.href = url;
							anchorElement.download = `${crypto.randomUUID().replace(/\-/g, emptyString).substring(0, 16)}_${Date.now()}.txt`;
							anchorElement.className = "hidden";
							document.body.appendChild(anchorElement);
							anchorElement.click();
							document.body.removeChild(anchorElement);
							URL.revokeObjectURL(url);
							showToast("Download triggered", true);
						} else {
							showToast("Nothing to download", false);
						}
					}, "Failed to download");
				};
				const calculateRatio = (inputByteCount, outputByteCount) => {
					const size = outputByteCount > inputByteCount ? "larger" : "smaller";
					if (inputByteCount && outputByteCount) {
						const ratio = Math.abs(((inputByteCount - outputByteCount) / inputByteCount) * 100).toFixed(2);
						return `(${ratio}% ${size})`;
					}
					return emptyString;
				};
				const updateStatistics = () => {
					const encryptedOutput = txtEncryptedOutput.value;
					const trailingSpaceCount = encryptedOutput.match(/\s+$/)?.[0]?.length;
					const plainTextByteCount = new Blob([txtPlainText.value]).size;
					const encryptedOutputByteCount = new Blob([encryptedOutput]).size;
					const cipherTextByteCount = new Blob([txtCipherText.value]).size;
					const deccryptedOutputByteCount = new Blob([txtDecryptedOutput.value]).size;
					spnTrailingSpaceCount.textContent = trailingSpaceCount ?? "0";
					divTrailingSpacesMessage.classList.toggle("hidden", !trailingSpaceCount);
					emPlainTextByteCount.textContent = plainTextByteCount;
					emEncryptedOutputByteCount.textContent = encryptedOutputByteCount;
					emCipherTextByteCount.textContent = cipherTextByteCount;
					emDecryptedOutputByteCount.textContent = deccryptedOutputByteCount;
					emPlainToEncryptedRatio.textContent = calculateRatio(plainTextByteCount, encryptedOutputByteCount);
					emEncryptedToPlainRatio.textContent = calculateRatio(cipherTextByteCount, deccryptedOutputByteCount);
				};
				divToast.addEventListener("transitionend", () => {
					if (divToast.className === "toast") {
						divToast.textContent = emptyString;
					}
				});
				divToast.addEventListener("click", hideToast);
				ancInsertSample.addEventListener("click", async () => {
					await withUiBlocked(async () => {
						await insertSampleText("en", txtPlainText);
					}, "Failed to insert sample text");
				});
				btnEncrypt.addEventListener("click", async () => {
					await withUiBlocked(async () => {
						const encryptIv = crypto.getRandomValues(new Uint8Array(ivLength));
						const input = txtPlainText.value;
						if (input) {
							const encryptedBytes = await encryptMessage(encryptKey, encryptIv, await unicodeToBase95(input));
							const combinedArray = new Uint8Array(ivLength + encryptedBytes.byteLength);
							combinedArray.set(encryptIv, 0);
							combinedArray.set(new Uint8Array(encryptedBytes), ivLength);
							await updateValue(txtEncryptedOutput, encodeBase95(combinedArray));
							showToast("Encryption successful", true);
						} else {
							showToast("Nothing to encrypt", false);
						}
					}, "Failed to encrypt");
				});
				btnDecrypt.addEventListener("click", async () => {
					await withUiBlocked(async () => {
						const decryptKeySecret = txtDecryptKey.value;
						if (!decryptKeySecret) {
							showToast("Key must be a non-empty string", false);
							return;
						}
						const cipherText = txtCipherText.value;
						if (cipherText) {
							const decryptKey = await crypto.subtle.importKey(
								keyFormat,
								Object.assign(jwkBase, {
									k: decryptKeySecret
								}),
								keyName,
								true,
								keyOps
							);
							const combinedArray = decodeBase95(cipherText);
							const decryptIv = combinedArray.slice(0, ivLength);
							const decryptedBytes = await decryptMessage(decryptKey, decryptIv, combinedArray.slice(ivLength));
							await updateValue(txtDecryptedOutput, await base95ToUnicode(decryptedBytes));
							showToast("Decryption successful", true);
						} else {
							showToast("Nothing to decrypt", false);
						}
					}, "Failed to decrypt");
				});
				[txtPlainText, txtEncryptedOutput, txtCipherText, txtDecryptedOutput].forEach(x => {
					x.addEventListener("input", updateStatistics);
				});
				tmpQrCode.addEventListener("load", async () => {
					const canQrCode = document.createElement("canvas");
					const ctxCanQrCode = canQrCode.getContext("2d");
					canQrCode.height = imgDim;
					canQrCode.width = imgDim;
					ctxCanQrCode.drawImage(tmpQrCode, 0, 0, imgDim, imgDim);
					imgEncryptKeyQrCode.src = canQrCode.toDataURL();
				});
				document.querySelectorAll(".tab-container").forEach(tabContainer => {
					const tabBarButtons = tabContainer.querySelectorAll("&> .tab-bar > .tab-btn");
					tabBarButtons.forEach(button => {
						button.addEventListener("click", () => {
							tabBarButtons.forEach(x => x.classList.remove("active"));
							tabContainer.querySelectorAll("&> .tab-panel").forEach(tp => tp.classList.add("hidden"));
							tabContainer.querySelector(`&> [data-name="${button.getAttribute("data-href")}"]`)?.classList.remove("hidden");
							button.classList.add("active");
						});
					});
					const defaultPanelName = tabContainer.getAttribute("data-default");
					if (defaultPanelName) {
						tabContainer.querySelector(`&> .tab-bar > [data-href="${defaultPanelName}"]`)?.dispatchEvent(new Event("click"));
					}
				});
				document.querySelectorAll(".btn-paste").forEach(btnPaste => {
					btnPaste.addEventListener("click", pasteToTarget);
				});
				document.querySelectorAll(".btn-copy").forEach(btnCopy => {
					btnCopy.addEventListener("click", copyFromSource);
				});
				document.querySelectorAll(".btn-upload").forEach(btnUpload => {
					btnUpload.addEventListener("click", triggerUpload);
				});
				document.querySelectorAll(".btn-download").forEach(btnDownload => {
					btnDownload.addEventListener("click", downloadFile);
				});
				document.querySelectorAll('input[type="file"]').forEach(fileInput => {
					fileInput.addEventListener("input", uploadFile);
				});
				txtEncryptKey.value = encryptKeySecret;
				txtEncryptedOutput.value = emptyString;
				txtDecryptedOutput.value = emptyString;
				tmpQrCode.src = `data:image/svg+xml;base64,${btoa(encryptKeyQr.outerHTML)}`;
				updateStatistics();
			});
		</script>
	</head>
	<body>
		<div id="toast" class="toast"></div>
		<div class="tab-container" data-default="tab-encrypt">
			<div class="tab-bar">
				<button class="tab-btn" data-href="tab-encrypt">Encrypt</button>
				<button class="tab-btn" data-href="tab-decrypt">Decrypt</button>
			</div>
			<div class="tab-panel hidden" data-name="tab-encrypt">
				<div class="grid">
					<div class="row">
						<div class="cell">
							<strong>Encryption Key</strong>
						</div>
						<div class="cell align-end">
							<button class="btn-copy" data-source="encrypt-key">Copy Key</button>
						</div>
					</div>
					<div class="row">
						<div class="cell">
							<div class="encrypt-key-holder">
								<textarea id="encrypt-key" class="key" readonly="readonly"></textarea>
								<div class="message">
									<span><strong>Important:</strong> This key changes with every page reload. Messages can only be decrypted with the exact key used for encryption. Share this key securely with your recipient, separately from the encrypted message. You can also share the QR code.</span>
								</div>
								<img id="encrypt-key-qr-code" class="qr-code" alt="Encryption key QR code"/>
							</div>
						</div>
					</div>
				</div>
				<br/>
				<div class="grid">
					<div class="row">
						<div class="cell">
							<strong>Plain Text Message</strong>
							<div class="separator"></div>
							<a id="insert-sample" href="javascript:void 0">Insert Sample</a>
						</div>
						<div class="cell align-end">
							<button class="btn-paste" data-target="plain-text">Paste</button>
							<input id="plain-text-file-input" type="file" class="hidden" data-target="plain-text"/>
							<button class="btn-upload" data-target="plain-text-file-input">Upload File</button>
							<button id="encrypt">Encrypt Message</button>
						</div>
					</div>
					<div class="row">
						<div class="cell">
							<textarea id="plain-text" placeholder="Enter your message here..."></textarea>
						</div>
					</div>
					<div class="row footer">
						<div class="cell">
							<em>Bytes:</em>
							<em id="plain-text-bytes">0</em>
						</div>
					</div>
				</div>
				<br/>
				<div class="grid">
					<div class="row">
						<div class="cell">
							<strong>Encrypted Output</strong>
						</div>
						<div class="cell align-end">
							<button class="btn-copy" data-source="encrypted-output">Copy Output</button>
							<button class="btn-download" data-source="encrypted-output">Download</button>
						</div>
					</div>
					<div id="trailing-spaces-message" class="row warning hidden">
						<div class="cell">
							<em>Warning: The encrypted text has <span id="trailing-space-count">0</span> trailing spaces. They will be prone to getting lost during storage/transmission.</em>
						</div>
					</div>
					<div class="row">
						<div class="cell">
							<textarea id="encrypted-output" readonly="readonly" placeholder="Encrypted message will appear here..."></textarea>
						</div>
					</div>
					<div class="row footer">
						<div class="cell">
							<em>Bytes:</em>
							<em id="encrypted-output-bytes">0</em>
							<em id="plain-to-encrypted-ratio"></em>
						</div>
					</div>
				</div>
			</div>
			<div class="tab-panel hidden" data-name="tab-decrypt">
				<div class="grid">
					<div class="row">
						<div class="cell">
							<strong>Decryption Key</strong>
						</div>
						<div class="cell align-end">
							<button class="btn-paste" data-target="decrypt-key">Paste Key</button>
						</div>
					</div>
					<div class="row">
						<div class="cell">
							<textarea id="decrypt-key" class="key" placeholder="Paste the decryption key here..."></textarea>
						</div>
					</div>
				</div>
				<br/>
				<div class="grid">
					<div class="row">
						<div class="cell">
							<strong>Encrypted Message</strong>
						</div>
						<div class="cell align-end">
							<button class="btn-paste" data-target="cipher-text">Paste</button>
							<input id="cipher-text-file-input" type="file" class="hidden" data-target="cipher-text"/>
							<button class="btn-upload" data-target="cipher-text-file-input">Upload File</button>
							<button id="decrypt">Decrypt Message</button>
						</div>
					</div>
					<div class="row">
						<div class="cell">
							<textarea id="cipher-text" placeholder="Paste the encrypted message here..."></textarea>
						</div>
					</div>
					<div class="row footer">
						<div class="cell">
							<em>Bytes:</em>
							<em id="cipher-text-bytes">0</em>
						</div>
					</div>
				</div>
				<br/>
				<div class="grid">
					<div class="row">
						<div class="cell">
							<strong>Decrypted Output</strong>
						</div>
						<div class="cell align-end">
							<button class="btn-copy" data-source="decrypted-output">Copy Output</button>
							<button class="btn-download" data-source="decrypted-output">Download</button>
						</div>
					</div>
					<div class="row">
						<div class="cell">
							<textarea id="decrypted-output" readonly="readonly" placeholder="Decrypted message will appear here..."></textarea>
						</div>
					</div>
					<div class="row footer">
						<div class="cell">
							<em>Bytes:</em>
							<em id="decrypted-output-bytes">0</em>
							<em id="encrypted-to-plain-ratio"></em>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div id="overlay" class="overlay hidden"></div>
	</body>
</html>